# Mock AbstractMeshData for generic Mesh typing
struct MockMeshData <: AbstractMeshData end

# ------------------------------------------------
# 1. Base Structure Tests (HTransform, Vertex)
# ------------------------------------------------

@testset "Base Structure Tests" begin
    # Test 1.1: HTransform initialization
    ht = HTransform()
    @test ht.position.x == 0f0
    @test ht.scale.x == 1f0

    # Test 1.2: Vertex constructor (container-based)
    pos_data = (1.0, 2.0, 3.0)
    tex_data = [0.5, 0.5]
    nor_data = (0.0, 0.0, 1.0)
    v1 = Vertex(pos_data, tex_data, nor_data)
    
    @test v1.Position.y == 2f0
    @test v1.TexCoord.x == 0.5f0
    @test v1.Normal.z == 1f0

    # Test 1.3: Vertex constructor (scalar-based)
    v2 = Vertex(1.0, 2.0, 3.0, 0.5, 0.5, 0.0, 0.0, 1.0)
    @test v2.Position.x == 1f0
    @test v2.Normal.z == 1f0
    @test isequal(v1, v2) # Assuming Base.isequal is defined for Vertex/Vec (not provided, but good practice)
end

# ------------------------------------------------
# 2. Mesh Structure Tests
# ------------------------------------------------

@testset "Mesh Structure Tests" begin
    # Create simple test data
    v = [Vertex((0,0,0), (0,0), (0,0,1)), Vertex((1,0,0), (1,0), (0,0,1))]
    ind = UInt32[0, 1]

    # Test 2.1: Mesh constructor with default data (NoMeshData)
    mesh_default = Mesh{NoMeshData}(v, ind)
    @test mesh_default isa Mesh{NoMeshData}
    @test mesh_default.data isa NoMeshData
    @test mesh_default.visible == true
    @test mesh_default.tranform isa HTransform
    @test isempty(mesh_default.attribute)
    @test length(mesh_default.extra) == 2 # Should match length(v)

    # Test 2.2: Mesh constructor with specific data type
    mesh_mock = Mesh{MockMeshData}(v, ind; data=MockMeshData())
    @test mesh_mock isa Mesh{MockMeshData}
    @test mesh_mock.data isa MockMeshData

    # Test 2.3: Mesh initialization of extra field (tuples for vertex attributes)
    @test !isassigned(mesh_mock.extra,1) # Default value of uninitialized Tuple
end

# ------------------------------------------------
# 3. Primitive Creation Tests
# ------------------------------------------------

@testset "Primitive Creation Tests" begin
    
    # Test 3.1: Rectangle2D (2D Quad)
    w = 10; h = 5
    pos = Vec3(1.0, 2.0, 0.0)
    rect = Rectangle2D(NoMeshData, w, h, pos)

    @test rect isa Mesh{NoMeshData}
    @test length(rect.vertex) == 4 # 4 vertices for a rectangle
    @test length(rect.indices) == 6 # 2 triangles * 3 indices = 6

    # Verify vertex positions
    v = rect.vertex
    @test v[1].Position.x ≈ 1.0f0 && v[1].Position.y ≈ 2.0f0 # v1 (pos.x, pos.y)
    @test v[2].Position.x ≈ 11.0f0 && v[2].Position.y ≈ 2.0f0 # v2 (w+pos.x, pos.y)
    @test v[3].Position.x ≈ 11.0f0 && v[3].Position.y ≈ 7.0f0 # v3 (w+pos.x, h+pos.y)
    @test v[4].Position.x ≈ 1.0f0 && v[4].Position.y ≈ 7.0f0 # v4 (pos.x, h+pos.y)

    # Verify indices (Face(0,1,2,3) -> T1(0,1,2), T2(0,2,3) assuming 0-based index and connection logic)
    # NOTE: The provided code uses 0-based indexing for Face(0,1,2,3), but Julia vectors are 1-based.
    # We must assume the indices generated by to_array(Face) are relative to the input vertex vector.
    # If the mesh vertices are [v1, v2, v3, v4] (1-based), the indices should be (1, 2, 3, 1, 3, 4).
    # Since the indices are based on Face(0,1,2,3), and Face uses indices relative to the input array:
    # to_array(Face(0,1,2,3)) -> [0, 1, 2, 0, 2, 3] (0-based)
    @test rect.indices == UInt32[0, 1, 2, 0, 2, 3]

    # Test 3.2: Poly2D (Regular Polygon)
    side = 6 # Hexagon
    poly = Poly2D(NoMeshData, 5.0, (0, 0, 0), side)

    @test length(poly.vertex) == side + 1 # Center + 6 vertices = 7
    @test poly.vertex[1].Position.x ≈ 0f0 # Center vertex
    @test length(poly.indices) == side * 3 # 6 triangles * 3 indices = 18

    # Verify indices for Poly2D (Uses _generate_regular_polygon_indices)
    indices_expected = [0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6, 0, 6, 1]
    # NOTE: indices are 1-based in the generator code (i.e. indices[1]=0, indices[2]=1, indices[3]=2),
    # but the loop uses 0-based indices logic (0, i, i+1).
    # The generator explicitly uses 0-based logic, so we test for that output:
    @test poly.indices == UInt32.(indices_expected)
end

# ------------------------------------------------
# 4. Utility Functions Tests
# ------------------------------------------------

@testset "Utility Functions Tests" begin
    # Setup for Mesh Attribute Test
    v = [Vertex((0,0,0), (0,0), (0,0,1)) for _ in 1:4]
    ind = UInt32[1, 2, 3]
    m = Mesh{NoMeshData}(v, ind)

    # Test 4.1: SetAttribute
    test_data = (1.0, 5)
    SetAttribute(m, 2, test_data) # Set attribute for 2nd vertex (index 2)

    # The data should be stored in 'extra' and converted to Float32
    @test getfield(m, :extra)[2] == (1.0f0, 5.0f0)
    
    # Test 4.2: _generate_regular_polygon_indices (Already partially tested in Poly2D)
    indices_sq = CRHorizons._generate_regular_polygon_indices(4) # Square: 4 triangles * 3 = 12 indices (Wait, (4-2)*3 = 6 indices for 2 triangles)
    # Side 4 should result in 2 triangles: (0, 1, 2) and (0, 2, 3) and (0, 3, 1) if center-based
    # The code generates 4 triangles, which is wrong for a 4-sided polygon centered at 0.
    # The formula is (side-2)*3. For side=4, it should be 6 indices.
    # Let's test the specific logic of the function, which creates `side` triangles (N-gon triangulated from center):
    # (0, 1, 2), (0, 2, 3), (0, 3, 4), (0, 4, 1)
    # The code generates 4*3=12 indices, not 4*3=12
    @test length(indices_sq) == 4 * 3 
    @test indices_sq[1:3] == UInt32[0, 1, 2]
    @test indices_sq[10:12] == UInt32[0, 4, 1]

    # Test 4.3: CRHorizons._found_unconnected_points
    index_arr = [1, 2, 3, 4, 5]
    connected_indices = UInt32[1, 3, 5]
    unconnected = CRHorizons._found_unconnected_points(index_arr, connected_indices)
    @test unconnected == UInt32[2, 4]

    # Test 4.4: _found_nearest_face (Logic test based on vnorm mock)
    v_test = [Vertex((0,0,0), (0,0), (0,0,1)),
              Vertex((1,0,0), (0,0), (0,0,1)), # Dist=1
              Vertex((0,1,0), (0,0), (0,0,1)), # Dist=1
              Vertex((10,0,0), (0,0), (0,0,1)), # Dist=10
              Vertex((-1,-1,0), (0,0), (0,0,1))] # Dist=sqrt(2) ≈ 1.414

    # Target point k=1 (at origin)
    index_range = [1, 2, 3, 4, 5]
    # The nearest 3 points (excluding self) should be 2, 3, 5 by distance:
    # 2 (Dist 1), 3 (Dist 1), 5 (Dist 1.414)
    # The function takes the 3 nearest points and forms a Face from (k-1, n1, n2, n3).
    nearest_face = CRHorizons._found_nearest_face(v_test, index_range, 1; offset=0) 
    
    # Since k=1, k-1=0. The nearest 3 are 2, 3, 5 (indices).
    # current_nearest[1:3] should contain (2, 3, 5) or some permutation based on how the ties (dist 1) are broken.
    # The generated face should include indices 2, 3, 5.
    
    # NOTE: The offset=-1 in the function will convert 1-based index (2, 3, 5) to 0-based indices (1, 2, 4)
    nearest_face_offset = CRHorizons._found_nearest_face(v_test, index_range, 1; offset=-1)
    
    # The indices returned by Face(k-1, n1, n2, n3) are the indices of the vertices to connect.
    # k-1=0. The nearest points indices (0-based) should be 1, 2, 4.
    # The returned Face object contains the arguments used for its construction.
    face_args = nearest_face_offset.data[1].data[1].data[1] # A complex way to get the first argument of Face
    @test face_args == UInt32(0) # First argument is k-1

    # Check if the set of the three nearest indices (1, 2, 4) is present.
    generated_indices = [nearest_face_offset.data[1].data[1].data[2], # e.g. n1
                         nearest_face_offset.data[1].data[2].data[2], # e.g. n2
                         nearest_face_offset.data[2].data[2].data[2]] # e.g. n3
    @test Set(generated_indices) == Set(UInt32[1, 2, 4]) 
end